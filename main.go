package main

import (
	"books-vector-api/log"
	"books-vector-api/outbox"
	"books-vector-api/vector"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"

	// "go.mongodb.org/mongo-driver/bson/primitive"

	"github.com/google/uuid"
)

// local config.json >>>
//
//	{
//	  "OllamaURL": "http://localhost:11434/api/embeddings",
//	  "MongoURI": "mongodb+srv://<username>:<password>@wenku-vector.gsmjtbg.mongodb.net/?retryWrites=true&w=majority&appName=wenku-vector",
//	  "DatabaseName": "vector_db",
//	  "Collection": "embeddings"
//	}
type Config struct {
	OllamaURL string `json:"OllamaURL"`

	ModelProviderURI    string `json:"ModelProviderURI"`
	ModelProviderModel  string `json:"ModelProviderModel"`
	ModelProviderAPIKey string `json:"ModelProviderAPIKey"`

	Collection       string `json:"Collection"`
	ChromaDBURL      string `json:"ChromaDBURL"`
	ChromDBTenants   string `json:"ChromDBTenants"`
	ChromaDBDatabase string `json:"ChromaDBDatabase"`
}

var config Config
var Logger *log.DailyLogger

func init() {
	// ‰ΩøÁî®Áõ∏ÂØπË∑ØÂæÑ
	Logger = log.New("./logs")

	file, err := os.Open("config.json")
	if err != nil {
		panic(fmt.Sprintf("Êó†Ê≥ïÊâìÂºÄÈÖçÁΩÆÊñá‰ª∂: %v", err))
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&config); err != nil {
		panic(fmt.Sprintf("Ëß£ÊûêÈÖçÁΩÆÊñá‰ª∂Â§±Ë¥•: %v", err))
	}

	outbox.InitModelProvider(config.ModelProviderURI, config.ModelProviderModel, config.ModelProviderAPIKey)
	outbox.Init(Logger)

	// Ê£ÄÊü•ÁßüÊà∑ addTenant ÊòØÂê¶Â≠òÂú®
	fmt.Println("üåçÊ≠£Âú®Ê∑ªÂä†ÁßüÊà∑...")
	if err := addTenants(); err != nil {
		panic(fmt.Sprintf("Ê∑ªÂä†ÁßüÊà∑Â§±Ë¥•: %v", err))
	}
	fmt.Println("üåçÊ≠£Âú®ÂàõÂª∫Êï∞ÊçÆÂ∫ì...")
	if err := addDatabases(); err != nil {
		panic(fmt.Sprintf("ÂàõÂª∫Êï∞ÊçÆÂ∫ìÂ§±Ë¥•: %v", err))
	}
	fmt.Println("üåçÊ≠£Âú®Ê∑ªÂä†EmbeddingÈõÜÂêà...")
	if err := addEmbeddingCollection(); err != nil {
		panic(fmt.Sprintf("Ê∑ªÂä†EmbeddingÈõÜÂêàÂ§±Ë¥•: %v", err))
	}
}

// OllamaÂìçÂ∫îÁªìÊûÑ
type OllamaResponse struct {
	Embedding []float32 `json:"embedding"`
}

func addTenants() error {
	// ÂÖàÊ£ÄÊü•ÁßüÊà∑ÊòØÂê¶Â≠òÂú® /api/v2/tenants/{tenant_name} get
	existURL := fmt.Sprintf("%s/tenants/%s", config.ChromaDBURL, config.ChromDBTenants)
	existsResp, err := http.Get(existURL)
	if err != nil {
		return fmt.Errorf("failed to check tenant: %v", err)
	}
	if existsResp.StatusCode == http.StatusOK {
		// Â≠òÂú®ÂàôËøîÂõû
		fmt.Println("ÁßüÊà∑Â∑≤Â≠òÂú®")
		return nil
	}
	defer existsResp.Body.Close()

	// ÂàõÂª∫ÁßüÊà∑ /api/v2/tenants post
	tenantsURL := fmt.Sprintf("%s/tenants", config.ChromaDBURL)
	payload := struct {
		Name string `json:"name"`
	}{
		Name: config.ChromDBTenants,
	}
	body, _ := json.Marshal(payload)
	resp, err := http.Post(tenantsURL, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return fmt.Errorf("failed to create tenant: %v", err)
	}
	defer resp.Body.Close()
	fmt.Println("ÂàõÂª∫ÁßüÊà∑ÊàêÂäü")
	return nil
}

func addDatabases() error {
	// Ê£ÄÊü•Êï∞ÊçÆÂ∫ìÊòØÂê¶Â≠òÂú® /api/v2/tenants/{tenant}/databases/{database} get
	existsURL := fmt.Sprintf("%s/tenants/%s/databases/%s", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase)
	existsResp, err := http.Get(existsURL)
	if err != nil {
		return fmt.Errorf("failed to check database existence: %v", err)
	}
	defer existsResp.Body.Close()
	if existsResp.StatusCode == http.StatusOK {
		fmt.Println("Êï∞ÊçÆÂ∫ìÂ∑≤Â≠òÂú®")
		return nil
	}
	// ÂàõÂª∫Êï∞ÊçÆÂ∫ì /api/v2/tenants/{tenant}/databases post
	createURL := fmt.Sprintf("%s/tenants/%s/databases", config.ChromaDBURL, config.ChromDBTenants)
	payload := struct {
		Name string `json:"name"`
	}{
		Name: config.ChromaDBDatabase,
	}
	body, _ := json.Marshal(payload)
	resp, err := http.Post(createURL, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return fmt.Errorf("failed to create database: %v", err)
	}
	defer resp.Body.Close()
	fmt.Println("ÂàõÂª∫Êï∞ÊçÆÂ∫ìÊàêÂäü")
	return nil
}

var CollectionId string

func addEmbeddingCollection() error {
	// Ê£ÄÊü•Áî®‰∫é embedding ÁöÑÈõÜÂêàÊòØÂê¶Â≠òÂú® /api/v2/tenants/{tenant}/databases/{database}/collections get
	existsURL := fmt.Sprintf("%s/tenants/%s/databases/%s/collections", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase)
	existsResp, err := http.Get(existsURL)
	if err != nil {
		return fmt.Errorf("failed to check collection existence: %v", err)
	}
	defer existsResp.Body.Close()
	if existsResp.StatusCode == http.StatusOK {
		// ÈÅçÂéÜ existsResp.BodyÔºåÂåπÈÖç name == config.Collection ÁöÑÈõÜÂêàÔºåÂ∞ÜÂÖ∂ id ËµãÂÄºÂà∞ CollectionId
		var existsRespBody []struct {
			Name string `json:"name"`
			ID   string `json:"id"`
		}
		json.NewDecoder(existsResp.Body).Decode(&existsRespBody)
		for _, collection := range existsRespBody {
			if collection.Name == config.Collection {
				CollectionId = collection.ID
			}
		}
		if CollectionId != "" {
			fmt.Println("Embedding ÈõÜÂêàÂ∑≤Â≠òÂú®: ", CollectionId)
			return nil
		}
	}
	// ÂàõÂª∫Áî®‰∫é embedding ÁöÑÈõÜÂêà /api/v2/tenants/{tenant}/databases/{database}/collections post
	createURL := fmt.Sprintf("%s/tenants/%s/databases/%s/collections", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase)
	payload := struct {
		Name      string            `json:"name"`
		Metadatas map[string]string `json:"metadatas"`
	}{
		Name: config.Collection,
		Metadatas: map[string]string{
			"hnsw:space": "ip", // "cosine" "12" "ip"
		},
	}
	body, _ := json.Marshal(payload)
	resp, err := http.Post(createURL, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return fmt.Errorf("failed to create collection: %v", err)
	}
	defer resp.Body.Close()
	// Â∞Ü resp.Body ÁöÑ id ËµãÂÄºÂà∞ CreationId
	var respBody struct {
		ID   string `json:"id"`
		Name string `json:"name"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&respBody); err != nil {
		return fmt.Errorf("failed to decode response body: %v", err)
	}
	CollectionId = respBody.ID
	fmt.Println("Collection created: ", CollectionId)
	return nil
}

func addToChromaDB(id string, embedding []float32, content string) (string, error) {
	// fmt.Println("Adding to ChromaDB...", embedding)

	// ÊûÑÈÄ†ËØ∑Ê±Ç‰Ωì
	payload := struct {
		Ids        []string            `json:"ids"`
		Embeddings [][]float32         `json:"embeddings"`
		Metadatas  []map[string]string `json:"metadatas,omitempty"`
	}{
		Ids:        []string{id},
		Embeddings: [][]float32{embedding},
		Metadatas: []map[string]string{
			{"content": content},
		},
	}
	// fmt.Println("payload:", payload)
	body, _ := json.Marshal(payload)
	// /api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/add post
	url := fmt.Sprintf("%s/tenants/%s/databases/%s/collections/%s/add", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase, CollectionId)
	// fmt.Println("url:", url)
	// url := fmt.Sprintf("%s/collections/%s/add", config.ChromaDBURL, collectionName)
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		fmt.Println("Error:", err)
		return "", err
	}
	defer resp.Body.Close()
	fmt.Println("Response Status:", resp.Status)
	// Â¶ÇÊûú resp.StatusCode Á≠â‰∫é 201 ÊàñËÄÖ 200 ËøîÂõû id
	if resp.StatusCode == http.StatusCreated || resp.StatusCode == http.StatusOK {
		return id, nil
	}
	bodyBytes, _ := io.ReadAll(resp.Body)
	return "", fmt.Errorf("failed to add to chromadb: %s", string(bodyBytes))
}

func generateAndStore(text string) (string, error) {
	embedding, err := generateEmbedding(text)
	if err != nil {
		return "", err
	}

	// id ‰ΩøÁî® UUIDv4 ÁîüÊàê
	id := strings.ReplaceAll(uuid.New().String(), "-", "")
	// fmt.Println("Adding to ChromaDB...", response)
	id, err = addToChromaDB(id, embedding, text)
	fmt.Println(id, err)
	if err != nil {
		return "failed to add to chromadb:", err
	}
	return id, nil
}

// Áã¨Á´ãÂêëÈáèÁîüÊàêÂáΩÊï∞ÔºàÂ§çÁî®Â≠òÂÇ®ÈÄªËæë‰∏≠ÁöÑÊ†∏ÂøÉÈÉ®ÂàÜÔºâ -> L2
func generateEmbedding(text string) ([]float32, error) {
	resp, err := http.Post(config.OllamaURL, "application/json",
		bytes.NewBufferString(fmt.Sprintf(`{"model":"nomic-embed-text","prompt":"%s"}`, url.QueryEscape(text))))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var response OllamaResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, err
	}

	L2 := vector.Normalize(response.Embedding)
	return L2, nil
}

// Âà†Èô§ËÆ∞ÂΩï
func deleteRecord(recordID string) (string, error) {
	// /api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/delete post
	url := fmt.Sprintf("%s/tenants/%s/databases/%s/collections/%s/delete", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase, CollectionId)
	payload := struct {
		IDs []string `json:"ids"`
	}{
		IDs: []string{recordID},
	}
	body, err := json.Marshal(payload)
	if err != nil {
		return "", err
	}
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("HTTP request failed with status code %d", resp.StatusCode)
	}
	return recordID, nil
}

type VectorSearchResponse struct {
	IDs        [][]string                 `json:"ids"`
	Embeddings [][]float32                `json:"embeddings"`
	Documents  [][]interface{}            `json:"documents"`
	Metadatas  [][]map[string]interface{} `json:"metadatas"`
	Distances  [][]float32                `json:"distances"`
	Include    []string                   `json:"include"`
}

//	type EmbeddingDoc struct {
//	    ids       string                 `bson:"ids"`
//	    metadatas map[string]interface{} `bson:"metadatas"`
//	}
//
// ÂêëÈáèÁõ∏‰ººÊÄßÊ£ÄÁ¥¢
func vectorSearch(queryVector []float32) ([]map[string]interface{}, error) {
	// url := fmt.Sprintf("%s/tenants/%s/databases/%s/collections/%s/add", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase, CollectionId)
	// Ê£ÄÁ¥¢ /api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/query post
	url := fmt.Sprintf("%s/tenants/%s/databases/%s/collections/%s/query", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase, CollectionId)

	payload := struct {
		QueryEmbeddings [][]float32 `json:"query_embeddings"`
		NResults        int         `json:"n_results"`
	}{
		QueryEmbeddings: [][]float32{queryVector},
		NResults:        5,
	}
	body, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		fmt.Println("Error:", err)
		return nil, err
	}
	// ÊâìÂç∞ resp.body Âπ∂Ê†ºÂºèÂåñ
	defer resp.Body.Close()
	// bodyBytes, err := io.ReadAll(resp.Body)
	// if err != nil {
	// 	return nil, err
	// }
	// fmt.Println("Response Body:", string(bodyBytes))
	var response VectorSearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, err
	}

	// Â¶ÇÊûúÈúÄË¶ÅËΩ¨Êç¢‰∏∫ EmbeddingDoc ÂàáÁâáÔºåÂèØ‰ª•ÊâãÂä®Êò†Â∞Ñ
	// ‰øùÂ≠òÊúÄÁªàÁªìÊûúÔºåÊØè‰∏™Êü•ËØ¢ÂØπÂ∫î‰∏ÄÁªÑÂåπÈÖçÈ°π
	var allResults []map[string]interface{}

	// Â§ñÂ±ÇÈÅçÂéÜÔºöÊØè‰∏™Êü•ËØ¢ÂêëÈáèÔºàÈÄöÂ∏∏ÊòØ1‰∏™Ôºâ
	for i := range response.IDs {
		// ÂÜÖÂ±ÇÈÅçÂéÜÔºöÊØè‰∏™ÂåπÈÖçÈ°π
		for j := range response.IDs[i] {
			resultItem := map[string]interface{}{
				"id":       response.IDs[i][j],
				"metadata": response.Metadatas[i][j],
				// ÂèØÈÄâÔºöÊ∑ªÂä†Ë∑ùÁ¶ª‰ø°ÊÅØ
				// "distance": response.Distances[i][j],
			}
			allResults = append(allResults, resultItem)
		}
	}
	return allResults, nil
}

type VectorGetRessponse struct {
	IDs        []string    `json:"ids"`
	Embeddings [][]float32 `json:"embeddings"`
}

func vectorCompare(text string, id string) (bool, error) {
	fmt.Println("vectorCompare...", text, id)
	embeddings, err := generateEmbedding(text)
	if err != nil {
		return false, err
	}
	// ÈÄöËøá id Êü•ËØ¢ÂêëÈáè /api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get post
	url := fmt.Sprintf("%s/tenants/%s/databases/%s/collections/%s/get", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase, CollectionId)
	payload := struct {
		IDs     []string `json:"ids"`
		Include []string `json:"include"`
	}{
		IDs:     []string{id},
		Include: []string{"embeddings"},
	}
	body, err := json.Marshal(payload)
	if err != nil {
		return false, err
	}
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return false, err
	}
	// fmt.Println(resp)
	defer resp.Body.Close()
	var response VectorGetRessponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return false, err
	}
	// fmt.Println("response:", response.Embeddings[0])
	compareResults := vector.BatchCompare(embeddings, response.Embeddings[0], 0.99)
	// Â∞Ü compareResults ÊâìÂç∞‰∏∫Â≠óÁ¨¶‰∏≤
	// fmt.Println("compareResults:", compareResults)

	return compareResults, nil
}

type DocumentResponse struct {
	IDs       []string                 `json:"ids"`
	Metadatas []map[string]interface{} `json:"metadatas"`
}

func listDocuments(limit int, offset int) (DocumentResponse, error) {
	// Ëé∑ÂèñÂàóË°® /api/v2/tenants/{tenant}/databases/{database}/collections/{collection_id}/get post
	url := fmt.Sprintf("%s/tenants/%s/databases/%s/collections/%s/get", config.ChromaDBURL, config.ChromDBTenants, config.ChromaDBDatabase, CollectionId)
	// ËØ∑Ê±Ç‰Ωì limit offset include
	payload := struct {
		Limit   int      `json:"limit"`
		Offset  int      `json:"offset"`
		Include []string `json:"include"`
	}{
		Limit:   limit,
		Offset:  offset,
		Include: []string{"metadatas"},
	}

	body, err := json.Marshal(payload)
	if err != nil {
		return DocumentResponse{}, err
	}
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return DocumentResponse{}, err
	}
	defer resp.Body.Close()
	var response DocumentResponse
	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return DocumentResponse{}, err
	}
	return response, nil
}

// HTTPÊé•Âè£
func main() {
	http.HandleFunc("/generate", func(w http.ResponseWriter, r *http.Request) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, "ËØªÂèñËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		var requestData struct {
			Text string `json:"text"`
		}
		if err := json.Unmarshal(body, &requestData); err != nil {
			http.Error(w, "Ëß£ÊûêËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		id, err := generateAndStore(requestData.Text)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"id": id})
	})

	http.HandleFunc("/search", func(w http.ResponseWriter, r *http.Request) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, "ËØªÂèñËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		var requestData struct {
			Text string `json:"text"`
		}
		if err := json.Unmarshal(body, &requestData); err != nil {
			http.Error(w, "Ëß£ÊûêËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		text := requestData.Text
		fmt.Printf("search text: %s\n", text)
		// ÁîüÊàêÊñáÊú¨ÂêëÈáè
		vector, err := generateEmbedding(text)
		if err != nil {
			http.Error(w, "ÁîüÊàêÂêëÈáèÂ§±Ë¥•: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// ÊâßË°åÂêëÈáèÊ£ÄÁ¥¢
		results, err := vectorSearch(vector)
		// fmt.Printf("results: %v\n", results)
		if err != nil {
			http.Error(w, "Ê£ÄÁ¥¢Â§±Ë¥•: "+err.Error(), http.StatusInternalServerError)
			return
		}

		returnResults := make([]map[string]interface{}, len(results))
		for i, result := range results {
			content := result["metadata"].(map[string]interface{})["content"]
			returnResults[i] = map[string]interface{}{
				"id":      result["id"],
				"content": content,
			}
		}
		// fmt.Printf("returnResults: %v\n", returnResults)
		// ËøîÂõûÁõ∏‰ººÂÜÖÂÆπ
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(returnResults)
	})

	http.HandleFunc("/chat", Chat)

	http.HandleFunc("/compare", func(w http.ResponseWriter, r *http.Request) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, "ËØªÂèñËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		var requestData struct {
			Text string `json:"text"`
			ID   string `json:"id"`
		}
		if err := json.Unmarshal(body, &requestData); err != nil {
			http.Error(w, "Ëß£ÊûêËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		result, err := vectorCompare(requestData.Text, requestData.ID)
		if err != nil {
			http.Error(w, "ÊØîËæÉÂ§±Ë¥•: "+err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]bool{"result": result})
	})

	http.HandleFunc("/documents", func(w http.ResponseWriter, r *http.Request) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, "ËØªÂèñËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		var requestData struct {
			Limit  int `json:"limit"`
			Offset int `json:"offset"`
		}
		if err := json.Unmarshal(body, &requestData); err != nil {
			http.Error(w, "Ëß£ÊûêËØ∑Ê±Ç‰ΩìÂ§±Ë¥•", http.StatusBadRequest)
			return
		}

		documents, err := listDocuments(requestData.Limit, requestData.Offset)
		if err != nil {
			fmt.Println("Ëé∑ÂèñÊñáÊ°£Â§±Ë¥•:", err)
			http.Error(w, "Ëé∑ÂèñÊñáÊ°£Â§±Ë¥•", http.StatusInternalServerError)
			return
		}

		var allResults []map[string]interface{}

		for i := range documents.IDs {
			resultItem := map[string]interface{}{
				"id":       documents.IDs[i],
				"metadata": documents.Metadatas[i],
			}
			allResults = append(allResults, resultItem)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(allResults)
	})

	http.HandleFunc("/delete", func(w http.ResponseWriter, r *http.Request) {
		// ‰ªé query ÂèÇÊï∞ÂèñÂá∫ id
		id := r.URL.Query().Get("id")
		fmt.Println("Âà†Èô§ËÆ∞ÂΩï", id)
		recordID, err := deleteRecord(id)
		if err != nil {
			http.Error(w, "Âà†Èô§Â§±Ë¥•", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		// ËøîÂõû { id } ÁªìÊûÑ‰Ωì
		json.NewEncoder(w).Encode(map[string]string{"id": recordID})
	})

	// ÂàõÂª∫‰∏Ä‰∏™ task Êé•Âè£, postÔºå‰ΩøÁî® NewTask ÊñπÊ≥ï
	http.HandleFunc("/task", outbox.NewTask)
	// Áî®Êà∑ÂõûÁ≠î PlanningTask answer
	http.HandleFunc("/planning/task/answer", outbox.PlanningTaskAnswer)
	// Áî®Êà∑‰∏≠Êñ≠ PlanningTask
	http.HandleFunc("/planning/task/interrupt", outbox.InterruptTask)

	// ÂêØÂä®ÊúçÂä°
	fmt.Println("‚úÖ ÂêØÂä®ÊúçÂä°ÊàêÂäü -- Server running on :8080")
	http.ListenAndServe(":8080", nil)
}
